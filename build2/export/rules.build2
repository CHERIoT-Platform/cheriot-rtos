config [string] config.cheriot_rtos.board

if! $defined(config.cheriot_rtos.board)
  fail 'config.cheriot_rtos.board must be specified'

import! [dir_path] sdk = cheriot-rtos%dir{sdk}

board_file = $sdk/boards/$(config.cheriot_rtos.board).json

if $empty($path_search($board_file))
  fail "unknown board '$config.cheriot_rtos.board': file $board_file does not exist"

board = $json.load($board_file)

# Useful for debugging.
#
#info $serialize($board)

revoker = ($board[revoker])
devices = $object_names($board[devices])
simulation = ($board[simulation] != [null] ? $board[simulation] : false)
stack_hwm = ($board[stack_high_water_mark] != [null] ? $board[stack_high_water_mark] : false)

revokable_memory_start = ($board[revokable_memory_start])
if ($revokable_memory_start == [null])
  revokable_memory_start = ($board[instruction_memory][start])

interrupt_names = [string, null]
interrupt_config = [string, null]
for i: ($board[interrupts])
{
  na = ($i[name])
  nu = ($i[number])
  pr = ($i[priority])
  et = ($i[edge_triggered] != [null] ? $i[edge_triggered] : false)

  interrupt_names += "($interrupt_names != [null] ? ', ' : )$na=$nu"
  interrupt_config += "($interrupt_config != [null] ? ', ' : ){$nu,$pr,$et}"
}

# Report key information about the board.
#
config [config.report.module=cheriot-rtos] revoker
config [config.report.module=cheriot-rtos] devices
config [config.report.module=cheriot-rtos] simulation

cxx.std = 20
c.std   = 2x

# Specify these options as compiler mode (as opposed to in cc.coptions below)
# so that they are taken into account when detecting target, searach paths,
# etc.
#
cxx.mode = -target riscv32-unknown-unknown -nostdinc
c.mode   = -target riscv32-unknown-unknown -nostdinc

using cxx
using c
using c.as-cpp

hxx{*}: extension = h
cxx{*}: extension = cc

# Toolchain.
#
toolchain = $directory($effect($cxx.path))
ld = $toolchain/ld.lld
objdump = $toolchain/llvm-objdump

# Default and board options.
#
cc.coptions += \
  -Qunused-arguments \
  -mcpu=cheriot -mabi=cheriot -mxcheri-rvc -mrelax \
  -fshort-wchar -fomit-frame-pointer -fno-builtin -fno-exceptions \
  -fno-asynchronous-unwind-tables -fno-c++-static-destructors -fno-rtti \
  -Oz -g \
  -Werror

cxx.poptions += "-I$sdk/include/c++-config" "-I$sdk/include/libc++"
cc.poptions += "-I$sdk/include"

for i: ($board[driver_includes])
  cc.poptions += "-I$sdk/include/$i"

cc.poptions += -DTEMPORAL_SAFETY

for d: ($board[defines])
  cc.poptions += "-D$d"

# These come from the board JSON file.
#
cc.poptions += \
"-DCPU_TIMER_HZ=($board[timer_hz])" \
"-DTICK_RATE_HZ=($board[tickrate_hz])" \
"-DREVOKABLE_MEMORY_START=$string($revokable_memory_start, 16, 8)"

if $stack_hwm
  cc.poptions += -DCONFIG_MSHWM

if ($interrupt_names != [null])
  cc.poptions += "-DCHERIOT_INTERRUPT_NAMES=$interrupt_names"

if $simulation
  cc.poptions += -DSIMULATION

for d: $devices
  cc.poptions += "-DDEVICE_EXISTS_$d"

# Note: alias the ldscript{} target type from cheriot-rtos instead of deriving
# a new one since some of the scripts come from there.
#
define ldscript = $sdk/ldscript
ldscript{*}: extension = ldscript

define library: file
library{*}: extension = library

[rule_name=link_library] library{~'/(.+)/'}: obje{~'/(.+)/'} \
  $sdk/ldscript{library} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

define privileged_library: file
privileged_library{*}: extension = library

# Note: linked with the privileged compartment linker script.
#
[rule_name=link_privileged_library] privileged_library{~'/(.+)/'}: \
  obje{~'/(.+)/'} $sdk/ldscript{privileged-compartment} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

define compartment: file
compartment{*}: extension = compartment

[rule_name=link_compartment] compartment{~'/(.+)/'}: obje{~'/(.+)/'} \
  $sdk/ldscript{compartment} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

define privileged_compartment: file
privileged_compartment{*}: extension = compartment

[rule_name=link_privileged_compartment] privileged_compartment{~'/(.+)/'}: \
  obje{~'/(.+)/'} $sdk/ldscript{privileged-compartment} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

# Place all the cheriot-rtos-supplied targets into the cheriot-rtos/ so that
# they don't clash with user's. Inside mimic the source directory structure.
#
# @@ TODO: tighten linker script to only recognize special compartments
#    (allocator, scheduler, etc) inside cheriot-rtos/?
#
cheriot-rtos/
{
  core/
  {
    # @@ TODO: comes from somewhere?
    #
    cc.poptions += -DCHERIOT_AVOID_CAPRELOCS

    # The scheduler compartment is specific to the firmware (depends on the
    # number of threads) and we assume a project may want to produce multiple
    # firmwares in the same build. So we synthesize the appropriate
    # dependecies in the link_firmware rule to include the firmware name into
    # this compartment's name and its object file names.
    #
    scheduler/
    {
      # @@ TODO: some come from board JSON and user's firmware configuration.
      #
      cc.poptions += \
        -DSCHEDULER_ACCOUNTING=false \
        -DDEBUG_SCHEDULER=false

      if ($interrupt_config != [null])
        cc.poptions += "-DCHERIOT_INTERRUPT_CONFIGURATION=$interrupt_config"

      cc.coptions += -cheri-compartment=sched

      fsdir{./}: fsdir{../}
    }

    privileged_compartment{allocator}: allocator/obje{main} fsdir{./}

    allocator/
    {
      cc.poptions += -DDEBUG_ALLOCATOR=false -DNDEBUG
      cc.coptions += -cheri-compartment=alloc -fvisibility=hidden
      cxx.coptions += -fvisibility-inlines-hidden

      obje{main}: $sdk/core/allocator/cxx{main} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    privileged_library{token_library}: token_library/obje{token_unseal} fsdir{./}

    token_library/
    {
      cc.poptions += -DNDEBUG -DDEBUG_TOKEN_LIBRARY=false
      cc.coptions += -fvisibility=hidden

      obje{token_unseal}: $sdk/core/token_library/S{token_unseal} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    loader/
    {
      # @@ TODO: comes from somewhere.
      #
      cc.poptions += \
        -DDEBUG_LOADER=false \
        -DNDEBUG \
        -DCHERIOT_LOADER_STACK_SIZE=1024 \
        -DCHERIOT_LOADER_TRUSTED_STACK_SIZE=192

      cc.coptions += -fvisibility=hidden
      cxx.coptions += -fvisibility-inlines-hidden

      obje{boot-s}: $sdk/core/loader/S{boot} fsdir{./}

      obje{boot-c}: $sdk/core/loader/cxx{boot} fsdir{./}
      {
        cc.coptions += -O1
      }

      fsdir{./}: fsdir{../}
    }

    switcher/
    {
      cc.poptions += -DNDEBUG
      cc.coptions += -fvisibility=hidden

      obje{entry}: $sdk/core/switcher/S{entry} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    fsdir{./}: fsdir{../}
  }

  lib/
  {
    cc.poptions += -DNDEBUG
    cc.coptions += -fvisibility=hidden
    cxx.coptions += -fvisibility-inlines-hidden

    library{atomic1}: atomic1/obje{atomic1} fsdir{./}

    atomic1/
    {
      obje{atomic1}: $sdk/lib/atomic/cxx{atomic1} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{atomic4}: atomic4/obje{atomic4} fsdir{./}

    atomic4/
    {
      obje{atomic4}: $sdk/lib/atomic/cxx{atomic4} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{locks}: locks/obje{locks semaphore} fsdir{./}

    locks/
    {
      obje{locks}: $sdk/lib/locks/cxx{locks} fsdir{./}
      obje{semaphore}: $sdk/lib/locks/cxx{semaphore} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{crt}: crt/obje{cz} fsdir{./}

    crt/
    {
      obje{cz}: $sdk/lib/crt/c{cz} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{freestanding}: freestanding/obje{memcmp memcpy memset} fsdir{./}

    freestanding/
    {
      # @@ These are built without NDEBUG/-fvisibility=hidden. Wonder if an
      #    omission or intentional?
      #
      cc.poptions = $regex.filter_out_match($cc.poptions, '^-DNDEBUG$')
      cc.coptions = $regex.filter_out_match($cc.coptions, '^--fvisibility=hidden$')

      obje{memcmp}: $sdk/lib/freestanding/c{memcmp} fsdir{./}
      obje{memcpy}: $sdk/lib/freestanding/c{memcpy} fsdir{./}
      obje{memset}: $sdk/lib/freestanding/c{memset} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    fsdir{./}: fsdir{../}
  }
}

define firmware: file
firmware{*}: extension =

# The user is expected to set the `threads` variable on each firmware{}
# target. It should be a JSON array with one or more JSON object elements
# each containing the following members:
#
#  [string] compartment
#  [uint64] priority
#  [string] entry_point
#  [uint64] stack_size
#  [uint64] trusted_stack_frames
#
firmware{*}:
{
  [json_array, visibility=target] threads = [null]
}

define dump: file
dump{*}: extension = dump

define json: file
json{*}: extension = json

# @@ TODO: generate firmware.ldscript. Maybe generate it as part of the
#    firmware recipe (seeing that it will need a lot of info from firmware)?
#    But then won't be able to use the `in` module.
#
# Note: the order in which we specify things to link is no significant.
#
[rule_name=link_firmware] <firmware{~'/(.+)/'} dump{^'/\1/'} json{^'/\1/'}>: \
   compartment{~'/(.+)/'} \
   cheriot-rtos/core/loader/obje{boot-s boot-c} \
   cheriot-rtos/core/switcher/obje{entry} \
   cheriot-rtos/lib/library{atomic1 atomic4 locks crt freestanding} \
   cheriot-rtos/core/privileged_library{token_library} \
   cheriot-rtos/core/privileged_compartment{allocator} \
   cheriot-rtos/core/privileged_compartment{^'/\1..scheduler/'} \
   ldscript{firmware.ldscript} $ld $objdump
{{
  s = $path($filter($<, obje library privileged_library \
                             compartment privileged_compartment))
  l = $path($filter($<, ldscript))
  o = $path($>[0])
  d = $path($>[1])
  r = $path($>[2])

  diag ld $>

  $ld "--script=$l" --relax -o $o "--compartment-report=$r" $s
  $objdump -glxsdrS --demangle $o >$d
}}

# @@ TMP: these should be synthesized by the link_firmware rule.
#
# Use `.` (escaped as `..`) instead of, say, `-` or `_` as a separator between
# the firmware name and `scheduler` to minimize the chance of clashes between
# several firmware (though seeing that this is inside cheriot-rtos/core/, it's
# unclear what we could clash with).
#
cheriot-rtos/core/
{
  privileged_compartment{hello_world..scheduler}: scheduler/obje{hello_world..main} fsdir{.}

  scheduler/obje{hello_world..main}: $sdk/core/scheduler/cxx{main} fsdir{scheduler/}
  {
    cc.poptions += -DCONFIG_THREADS_NUM=1
  }
}
