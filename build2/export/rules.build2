config [string] config.cheriot_rtos.board

if! $defined(config.cheriot_rtos.board)
  fail 'config.cheriot_rtos.board must be specified'

import! [dir_path] sdk = cheriot-rtos%dir{sdk}

board = $sdk/boards/$(config.cheriot_rtos.board).json

if $empty($path_search($board))
  fail "unknown board '$config.cheriot_rtos.board': file $board does not exist"

# @@ TODO: load board file.

revoker = 'hardware'

# Report key information about the board.
#
config [config.report.module=cheriot-rtos] revoker

cxx.std = 20
c.std   = 2x

# Specify these options as compiler mode (as opposed to in cc.coptions below)
# so that they are taken into account when detecting target, searach paths,
# etc.
#
cxx.mode = -target riscv32-unknown-unknown -nostdinc
c.mode   = -target riscv32-unknown-unknown -nostdinc

using cxx
using c
using c.as-cpp

hxx{*}: extension = h
cxx{*}: extension = cc

# Toolchain.
#
toolchain = $directory($effect($cxx.path))
ld = $toolchain/ld.lld
objdump = $toolchain/llvm-objdump

# Default and board options.
#
cc.coptions += \
  -Qunused-arguments \
  -mcpu=cheriot -mabi=cheriot -mxcheri-rvc -mrelax \
  -fshort-wchar -fomit-frame-pointer -fno-builtin -fno-exceptions \
  -fno-asynchronous-unwind-tables -fno-c++-static-destructors -fno-rtti \
  -Oz -g \
  -Werror

cxx.poptions += "-I$sdk/include/c++-config" "-I$sdk/include/libc++"
cc.poptions += "-I$sdk/include"

# @@ TODO: these come from the board JSON file.
#
for d: ../include/platform/generic-riscv ../include/platform/ibex
  cc.poptions += "-I$sdk/include/$d"

cc.poptions += -DTEMPORAL_SAFETY

# @@ TODO: these come from the board JSON file.
#
for m: IBEX IBEX_SAFE
  cc.poptions += "-D$m"

# @@ TODO: these are computed based on values from the board JSON file.
#
cc.poptions += \
-DCPU_TIMER_HZ=100000 \
-DTICK_RATE_HZ=10 \
-DSIMULATION \
-DCONFIG_MSHWM \
-DDEVICE_EXISTS_clint \
-DDEVICE_EXISTS_plic \
-DDEVICE_EXISTS_revoker \
-DDEVICE_EXISTS_shadow \
-DDEVICE_EXISTS_uart \
-DREVOKABLE_MEMORY_START=0x20040000 \
"-DCHERIOT_INTERRUPT_NAMES=RevokerInterrupt=1, "

# @@ build2: why do we have to specify extension explicitly? Perhaps we are
#    not resolving ldscript{} in the right scope/project?
#
define ldscript: file
ldscript{*}: extension = ldscript

define library: file
library{*}: extension = library

[rule_name=link_library] library{~'/(.+)/'}: obje{~'/(.+)/'} \
  $sdk/ldscript{library.ldscript} $ld
{{
  s = $path($filter($<, obje))
  #l = $path($filter($<, file)) # @@ build2: looks like we loose file{} extension.
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

define privileged_library: file
privileged_library{*}: extension = library

# Note: linked with the privileged compartment linker script.
#
[rule_name=link_privileged_library] privileged_library{~'/(.+)/'}: \
  obje{~'/(.+)/'} $sdk/ldscript{privileged-compartment.ldscript} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

define compartment: file
compartment{*}: extension = compartment

[rule_name=link_compartment] compartment{~'/(.+)/'}: obje{~'/(.+)/'} \
  $sdk/ldscript{compartment.ldscript} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

define privileged_compartment: file
privileged_compartment{*}: extension = compartment

[rule_name=link_privileged_compartment] privileged_compartment{~'/(.+)/'}: \
  obje{~'/(.+)/'} $sdk/ldscript{privileged-compartment.ldscript} $ld
{{
  s = $path($filter($<, obje))
  l = $path($filter($<, ldscript))
  o = $path($>)

  diag ld $>

  $ld "--script=$l" --compartment --relax -o $o $s
}}

# Place all the cheriot-rtos-supplied targets into the cheriot-rtos/ so that
# they don't clash with user's. Inside mimic the source directory structure.
#
# @@ TODO: tighten linker script to only recognize special compartments
#    (allocator, scheduler, etc) inside cheriot-rtos/?
#
cheriot-rtos/
{
  core/
  {
    # @@ TODO: comes from somewhere?
    #
    cc.poptions += -DCHERIOT_AVOID_CAPRELOCS

    # The scheduler compartment is specific to the firmware (depends on the
    # number of threads) and we assume a project may want to produce multiple
    # firmwares in the same build. So we synthesize the appropriate
    # dependecies in the link_firmware rule to include the firmware name into
    # this compartment's name and its object file names.
    #
    scheduler/
    {
      # @@ TODO: some come from board JSON and user's firmware configuration.
      #
      cc.poptions += \
        -DSCHEDULER_ACCOUNTING=false \
        -DDEBUG_SCHEDULER=false \
        '-DCHERIOT_INTERRUPT_CONFIGURATION={1,2,false}'

      cc.coptions += -cheri-compartment=sched

      fsdir{./}: fsdir{../}
    }

    privileged_compartment{allocator}: allocator/obje{main} fsdir{./}

    allocator/
    {
      cc.poptions += -DDEBUG_ALLOCATOR=false -DNDEBUG
      cc.coptions += -cheri-compartment=alloc -fvisibility=hidden
      cxx.coptions += -fvisibility-inlines-hidden

      obje{main}: $sdk/core/allocator/cxx{main} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    privileged_library{token_library}: token_library/obje{token_unseal} fsdir{./}

    token_library/
    {
      cc.poptions += -DNDEBUG -DDEBUG_TOKEN_LIBRARY=false
      cc.coptions += -fvisibility=hidden

      obje{token_unseal}: $sdk/core/token_library/S{token_unseal} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    loader/
    {
      # @@ TODO: comes from somewhere.
      #
      cc.poptions += \
        -DDEBUG_LOADER=false \
        -DNDEBUG \
        -DCHERIOT_LOADER_STACK_SIZE=1024 \
        -DCHERIOT_LOADER_TRUSTED_STACK_SIZE=192

      cc.coptions += -fvisibility=hidden
      cxx.coptions += -fvisibility-inlines-hidden

      obje{boot-s}: $sdk/core/loader/S{boot} fsdir{./}

      obje{boot-c}: $sdk/core/loader/cxx{boot} fsdir{./}
      {
        cc.coptions += -O1
      }

      fsdir{./}: fsdir{../}
    }

    switcher/
    {
      cc.poptions += -DNDEBUG
      cc.coptions += -fvisibility=hidden

      obje{entry}: $sdk/core/switcher/S{entry} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    fsdir{./}: fsdir{../}
  }

  lib/
  {
    cc.poptions += -DNDEBUG
    cc.coptions += -fvisibility=hidden
    cxx.coptions += -fvisibility-inlines-hidden

    library{atomic1}: atomic1/obje{atomic1} fsdir{./}

    atomic1/
    {
      obje{atomic1}: $sdk/lib/atomic/cxx{atomic1} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{atomic4}: atomic4/obje{atomic4} fsdir{./}

    atomic4/
    {
      obje{atomic4}: $sdk/lib/atomic/cxx{atomic4} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{locks}: locks/obje{locks semaphore} fsdir{./}

    locks/
    {
      obje{locks}: $sdk/lib/locks/cxx{locks} fsdir{./}
      obje{semaphore}: $sdk/lib/locks/cxx{semaphore} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{crt}: crt/obje{cz} fsdir{./}

    crt/
    {
      obje{cz}: $sdk/lib/crt/c{cz} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    library{freestanding}: freestanding/obje{memcmp memcpy memset} fsdir{./}

    freestanding/
    {
      # @@ These are built without NDEBUG/-fvisibility=hidden. Wonder if an
      #    omission or intentional?
      #
      cc.poptions = $regex.filter_out_match($cc.poptions, '^-DNDEBUG$')
      cc.coptions = $regex.filter_out_match($cc.coptions, '^--fvisibility=hidden$')

      obje{memcmp}: $sdk/lib/freestanding/c{memcmp} fsdir{./}
      obje{memcpy}: $sdk/lib/freestanding/c{memcpy} fsdir{./}
      obje{memset}: $sdk/lib/freestanding/c{memset} fsdir{./}

      fsdir{./}: fsdir{../}
    }

    fsdir{./}: fsdir{../}
  }
}

define firmware: file
firmware{*}: extension =

define dump: file
dump{*}: extension = dump

define json: file
json{*}: extension = json

# @@ TODO: generate firmware.ldscript. Maybe generate it as part of the
#    firmware recipe (seeing that it will need a lot of info from firmware)?
#    But then won't be able to use the `in` module.
#
# Note: the order in which we specify things to link is no significant.
#
[rule_name=link_firmware] <firmware{~'/(.+)/'} dump{^'/\1/'} json{^'/\1/'}>: \
   compartment{~'/(.+)/'} \
   cheriot-rtos/core/loader/obje{boot-s boot-c} \
   cheriot-rtos/core/switcher/obje{entry} \
   cheriot-rtos/lib/library{atomic1 atomic4 locks crt freestanding} \
   cheriot-rtos/core/privileged_library{token_library} \
   cheriot-rtos/core/privileged_compartment{allocator} \
   cheriot-rtos/core/privileged_compartment{^'/\1-scheduler/'} \
   ldscript{firmware.ldscript} $ld $objdump
{{
  s = $path($filter($<, obje library privileged_library \
                             compartment privileged_compartment))
  l = $path($filter($<, ldscript))
  o = $path($>[0])
  d = $path($>[1])
  r = $path($>[2])

  diag ld $>

  $ld "--script=$l" --relax -o $o "--compartment-report=$r" $s
  $objdump -glxsdrS --demangle $o >$d
}}

# @@ TMP: these should be synthesized by the link_firmware rule.
#
# @@ TMP: use `.` instead of `-` as separator (also in linker script).
#
cheriot-rtos/core/
{
  privileged_compartment{hello_world-scheduler}: scheduler/obje{hello_world-main} fsdir{.}

  scheduler/obje{hello_world-main}: $sdk/core/scheduler/cxx{main} fsdir{scheduler/}
  {
    cc.poptions += -DCONFIG_THREADS_NUM=1
  }
}
